Problem ID: abc307_e
Problem Content:
There are N people numbered from 1 to N standing in a circle. Person 1 is to the right of person 2, person 2 is to the right of person 3, ..., and person N is to the right of person 1.
We will give each of the N people an integer between 0 and M-1, inclusive.
Among the M^N ways to distribute integers, find the number, modulo 998244353, of such ways that no two adjacent people have the same integer.

Input

The input is given from Standard Input in the following format:
N M

Output

Print the answer.

Constraints


- 2 \leq N,M \leq 10^6
- N and M are integers.

Sample Input 1

3 3

Sample Output 1

6

There are six desired ways, where the integers given to persons 1,2,3 are (0,1,2),(0,2,1),(1,0,2),(1,2,0),(2,0,1),(2,1,0).

Sample Input 2

4 2

Sample Output 2

2

There are two desired ways, where the integers given to persons 1,2,3,4 are (0,1,0,1),(1,0,1,0).

Sample Input 3

987654 456789

Sample Output 3

778634319

Be sure to find the number modulo 998244353.

Qwen2 Analysis:
The problem presented involves combinatorics and modular arithmetic, with constraints that indicate a potentially intricate calculation strategy might be needed. The high upper bound for both N and M (up to $10^6$) indicates an implementation complexity issue as well.

Given these points:

- **Category Prediction**: Based on the use of modular arithmetic, complex mathematical calculations, and constraints that imply large input sizes, this problem likely falls under the category of "Advanced Algorithm Design", specifically focusing on efficient calculation methods for combinatorial problems. It might involve elements from dynamic programming or combinatorial mathematics.

### Key Insight:

The problem requires counting sequences where no two adjacent numbers are equal out of all possible sequences generated by assigning each person a number between 0 and M-1. This is akin to finding the number of valid permutations under constraints, which can be approached using dynamic programming techniques that efficiently handle large input sizes while keeping track of transitions or states.

### Solution Approach:

1. **Dynamic Programming**: Use dynamic programming with memoization or tabulation to compute intermediate results for smaller subproblems efficiently. The state could include not only the current person (position) but also which number was assigned last, if allowed based on the constraints derived from adjacency conditions.

2. **Modular Arithmetic**: Since calculations need to be performed modulo 998244353, ensure all operations adhere to this modulus throughout computations to avoid overflow and maintain correctness of results.

### Implementation Steps:

1. Initialize a DP table where `dp[i][j]` represents the number of valid assignments for positions 1 through i with the last number being j.
   
2. Iterate through each person (position) and update counts based on previous states ensuring no adjacent numbers are equal under modular arithmetic constraints.

3. Calculate the final answer by summing up values where `dp[N][k]` is accessed, considering all possible outcomes for the first assignment as it doesn't have a previous element to consider.

4. Use efficient multiplication techniques modulo 998244353 (such as using fast exponentiation for powers of M) when updating states.

### Conclusion:

The problem involves deep algorithmic thinking and requires optimization due to its large scale inputs and constraints. It is likely designed to push boundaries in terms of computational complexity, requiring careful implementation of dynamic programming techniques tailored with efficient modular arithmetic operations to handle the constraints effectively.

To solve this problem successfully, one must demonstrate expertise in advanced algorithm design principles, specifically those pertaining to dynamic programming for combinatorial optimization problems under specific conditions and large-scale data manipulation using modular arithmetic.
